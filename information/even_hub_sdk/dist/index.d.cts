/**
 * Even App 消息接口
 *
 * 用于定义 Even App 和 WebView 之间传递的消息格式
 *
 * 消息是双向通信的基础，所有 Even App 和 WebView 之间的通信都使用这个格式
 */
interface EvenAppMessage {
    /**
     * 消息类型，用于标识消息的用途
     *
     * 常见的消息类型：
     * - call_even_app_method: Web 页面调用 Even App 方法
     * - listen_even_app_data: Web 页面监听 Even App 通知
     */
    type: string;
    /**
     * 事件名称
     *
     * 常见的事件名称：
     * - Type = call_even_app_method：
     *   - name = getUserInfo
     *   - name = getGlassesInfo
     *   - name = setLocalStorage
     *   - name = getLocalStorage
     *   - name = createStartUpPageContainer
     *   - name = rebuildPageContainer
     *   - name = updateImageRawData
     *   - name = textContainerUpgrade
     *   - name = shutDownPageContainer
     * - Type = listen_even_app_data:
     *   - name = deviceStatusChanged
     *   - name = evenHubEvent
     */
    method: string;
    /**
     * 消息数据（可选）
     * 包含消息的具体内容，根据不同的 type 会有不同的结构
     */
    data?: any;
    /**
     * 消息负载（可选），与 data 类似，用于向后兼容
     * 某些旧版本可能使用 payload 而不是 data
     */
    payload?: any;
}

/**
 * Even App 方法枚举
 *
 * 用于定义 Web 页面可以调用的 Even App 方法
 * 使用枚举可以避免硬编码字符串，提高代码可维护性
 */
declare enum EvenAppMethod {
    /** 获取用户信息 */
    GetUserInfo = "getUserInfo",
    /** 获取眼镜/设备信息 */
    GetGlassesInfo = "getGlassesInfo",
    /** 设置本地存储 */
    SetLocalStorage = "setLocalStorage",
    /** 获取本地存储 */
    GetLocalStorage = "getLocalStorage",
    /** EvenHub - 创建启动页容器 */
    CreateStartUpPageContainer = "createStartUpPageContainer",
    /** EvenHub - 重建页面容器 */
    RebuildPageContainer = "rebuildPageContainer",
    /** EvenHub - 更新图片原始数据 */
    UpdateImageRawData = "updateImageRawData",
    /** EvenHub - 文本容器升级 */
    TextContainerUpgrade = "textContainerUpgrade",
    /** EvenHub - 关闭页面容器 */
    ShutDownPageContainer = "shutDownPageContainer"
}
/**
 * Even App 消息类型枚举
 *
 * 用于定义 Even App 和 WebView 之间传递的消息类型
 */
declare enum EvenAppMessageType {
    /** Web 页面调用 Even App 方法 */
    CallEvenAppMethod = "call_even_app_method",
    /** Web 页面监听 Even App 通知 */
    ListenEvenAppNotify = "listen_even_app_data"
}
/**
 * Bridge 事件枚举
 *
 * 用于定义 Bridge 触发的自定义事件名称
 * 使用枚举可以避免硬编码字符串，方便事件名称的管理和查找
 */
declare enum BridgeEvent {
    /** 桥接就绪事件 - 当桥接初始化完成时触发 */
    BridgeReady = "evenAppBridgeReady",
    /** 设备状态变化事件 - 当设备状态（连接状态、电量等）发生变化时触发 */
    DeviceStatusChanged = "deviceStatusChanged",
    /** EvenHub 事件 - 当 EvenHub (PB) 推送事件发生时触发 */
    EvenHubEvent = "evenHubEvent"
}

/**
 * 用户信息类
 *
 * 用于描述 Even App 中的用户信息。
 */
declare class UserInfo {
    /** 用户 ID */
    uid: number;
    /** 用户名 */
    name: string;
    /** 用户头像 URL */
    avatar: string;
    /** 用户国家 */
    country: string;
    constructor(params: {
        uid: number;
        name: string;
        avatar: string;
        country: string;
    });
    /** 转换为 JSON 对象 */
    toJson(): Record<string, any>;
    /** 从 JSON 对象创建 UserInfo */
    static fromJson(json: any): UserInfo;
    /** 创建默认的 UserInfo 对象 */
    static createDefault(): UserInfo;
}

/**
 * 设备连接状态枚举
 *
 * 用于描述设备（眼镜/戒指等）的连接状态。
 * 注意：虽然当前多数场景来自 BLE，但这里不强绑定 BLE，因此命名为 DeviceConnectType。
 */
declare enum DeviceConnectType {
    /** 缺省状态，未初始化 */
    None = "none",
    /** 正在连接 */
    Connecting = "connecting",
    /** 连接成功 */
    Connected = "connected",
    /** 断开连接 */
    Disconnected = "disconnected",
    /** 连接失败 */
    ConnectionFailed = "connectionFailed"
}
declare namespace DeviceConnectType {
    /**
     * 从字符串值获取 DeviceConnectType 枚举
     *
     * @param value 字符串值
     * @returns 对应的 DeviceConnectType 枚举值，如果无法匹配则返回 None
     */
    function fromString(value: string): DeviceConnectType;
}

/**
 * 设备状态类
 *
 * 用于描述 Even 设备的实时状态信息。
 */
declare class DeviceStatus {
    /** 设备 SN（只读） */
    readonly sn: string;
    /** 连接状态 */
    connectType: DeviceConnectType;
    /** 是否佩戴中 */
    isWearing?: boolean;
    /** 电池电量 (0-100) */
    batteryLevel?: number;
    /** 是否正在充电 */
    isCharging?: boolean;
    /** 是否在充电盒中 */
    isInCase?: boolean;
    constructor(params: {
        sn: string;
        connectType?: DeviceConnectType;
        isWearing?: boolean;
        batteryLevel?: number;
        isCharging?: boolean;
        isInCase?: boolean;
    });
    /** 转换为 JSON 对象 */
    toJson(): Record<string, any>;
    /** 是否未初始化 */
    isNone(): boolean;
    /** 是否已连接 */
    isConnected(): boolean;
    /** 是否正在连接 */
    isConnecting(): boolean;
    /** 是否已断开 */
    isDisconnected(): boolean;
    /** 是否连接失败 */
    isConnectionFailed(): boolean;
    /** 从 JSON 对象创建 DeviceStatus */
    static fromJson(json: any): DeviceStatus;
    /** 创建默认的 DeviceStatus 对象 */
    static createDefault(sn?: string): DeviceStatus;
}

/**
 * 设备型号枚举
 *
 * 用于描述 Even 设备的具体型号
 */
declare enum DeviceModel {
    /** G1 眼镜 */
    G1 = "g1",
    /** G2 眼镜 */
    G2 = "g2",
    /** Ring1 戒指 */
    Ring1 = "ring1"
}
declare namespace DeviceModel {
    /**
     * 从字符串值获取 DeviceModel 枚举
     *
     * @param value 字符串值
     * @returns 对应的 DeviceModel 枚举值，如果无法匹配则返回 G1
     */
    function fromString(value: string): DeviceModel;
    /**
     * 检查设备型号是否是眼镜
     *
     * @param model 设备型号
     * @returns 是否是眼镜类型
     */
    function isGlasses(model: DeviceModel): boolean;
    /**
     * 检查设备型号是否是戒指
     *
     * @param model 设备型号
     * @returns 是否是戒指类型
     */
    function isRing(model: DeviceModel): boolean;
}

/**
 * 设备信息类
 *
 * 用于描述 Even 设备（眼镜/戒指）的基本信息。
 * - `model` / `sn` 创建后不可修改
 * - `status` 可更新，但要求 `status.sn === sn`
 */
declare class DeviceInfo {
    /** 设备型号（只读） */
    readonly model: DeviceModel;
    /** 设备序列号（只读） */
    readonly sn: string;
    /** 设备状态 */
    status: DeviceStatus;
    constructor(params: {
        model: DeviceModel;
        sn: string;
        status?: DeviceStatus;
    });
    /** 从 JSON 创建 DeviceInfo */
    static fromJson(json: any): DeviceInfo;
    /**
     * 更新设备状态（对齐 Dart `EhDeviceInfo.updateStatus` 的行为）。
     *
     * 说明：
     * - **原地更新** `this.status`
     * - 仅当 `status.sn === this.sn` 时才会更新
     * - 不一致时直接忽略（不修改）
     */
    updateStatus(status: DeviceStatus): void;
    /** 是否是眼镜 */
    isGlasses(): boolean;
    /** 是否是戒指 */
    isRing(): boolean;
    /** 转换为 JSON */
    toJson(): Record<string, any>;
}

/**
 * EvenHub 错误码/结果码
 *
 * 对齐宿主 PB：EvenHub_ErrorCode_List（见 EvenHub.pbenum.dart）
 * 注意：宿主（Flutter）侧可能返回枚举的 name（string）或 value（number）。
 */
/** EvenHub 错误码名称（与 PB enum 的名字保持一致） */
declare enum EvenHubErrorCodeName {
    APP_REQUEST_CREATE_PAGE_SUCCESS = "APP_REQUEST_CREATE_PAGE_SUCCESS",
    APP_REQUEST_CREATE_INVAILD_CONTAINER = "APP_REQUEST_CREATE_INVAILD_CONTAINER",
    APP_REQUEST_CREATE_OVERSIZE_RESPONSE_CONTAINER = "APP_REQUEST_CREATE_OVERSIZE_RESPONSE_CONTAINER",
    APP_REQUEST_CREATE_OUTOFMEMORY_CONTAINER = "APP_REQUEST_CREATE_OUTOFMEMORY_CONTAINER",
    APP_REQUEST_UPGRADE_IMAGE_RAW_DATA_SUCCESS = "APP_REQUEST_UPGRADE_IMAGE_RAW_DATA_SUCCESS",
    APP_REQUEST_UPGRADE_IMAGE_RAW_DATA_FAILED = "APP_REQUEST_UPGRADE_IMAGE_RAW_DATA_FAILED",
    APP_REQUEST_REBUILD_PAGE_SUCCESS = "APP_REQUEST_REBUILD_PAGE_SUCCESS",
    APP_REQUEST_REBUILD_PAGE_FAILD = "APP_REQUEST_REBUILD_PAGE_FAILD",
    APP_REQUEST_UPGRADE_TEXT_DATA_SUCCESS = "APP_REQUEST_UPGRADE_TEXT_DATA_SUCCESS",
    APP_REQUEST_UPGRADE_TEXT_DATA_FAILED = "APP_REQUEST_UPGRADE_TEXT_DATA_FAILED",
    APP_REQUEST_UPGRADE_SHUTDOWN_SUCCESS = "APP_REQUEST_UPGRADE_SHUTDOWN_SUCCESS",
    APP_REQUEST_UPGRADE_SHUTDOWN_FAILED = "APP_REQUEST_UPGRADE_SHUTDOWN_FAILED",
    APP_REQUEST_UPGRADE_HEARTBEAT_PACKET_SUCCESS = "APP_REQUEST_UPGRADE_HEARTBEAT_PACKET_SUCCESS"
}
/** 兼容宿主返回 string 或 number 两种形式 */
type EvenHubErrorCode = EvenHubErrorCodeName | number | string;

/**
 * EvenHub container property models
 *
 * 仅做“字段模型 + JSON 字段映射”，不做任何 protobuf 编解码。
 * 字段名优先使用 JS 侧常见 camelCase，同时兼容宿主可能透出的 protoName（如 Container_ID / List_Object）。
 */
/**
 * ListItemContainerProperty
 *
 * 对齐 PB：`List_ItemContainerProperty`
 */
declare class ListItemContainerProperty {
    /** 对应 PB：Item_Count */
    itemCount?: number;
    /** 对应 PB：Item_Width */
    itemWidth?: number;
    /** 对应 PB：Is_Item_Select_Border_En（0/1） */
    isItemSelectBorderEn?: number;
    /** 对应 PB：Item_Name */
    itemName?: string[];
    constructor(data?: Partial<ListItemContainerProperty>);
    /**
     * 将宿主下发的 JSON 转成 `ListItemContainerProperty`
     * - 自动兼容 key：camelCase / protoName
     */
    static fromJson(json: any): ListItemContainerProperty;
    static toJson(model?: ListItemContainerProperty | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}
/**
 * ListContainerProperty
 *
 * 对齐 PB：`ListContainerProperty`
 */
declare class ListContainerProperty {
    /** 对应 PB：X_Position */
    xPosition?: number;
    /** 对应 PB：Y_Position */
    yPosition?: number;
    /** 对应 PB：Width */
    width?: number;
    /** 对应 PB：Height */
    height?: number;
    /** 对应 PB：Border_Width */
    borderWidth?: number;
    /** 对应 PB：Border_Color */
    borderColor?: number;
    /** 对应 PB：Border_Rdaius（注意 PB 本身拼写为 Rdaius） */
    borderRdaius?: number;
    /** 对应 PB：Padding_Length */
    paddingLength?: number;
    /** 对应 PB：Container_ID */
    containerID?: number;
    /** 对应 PB：Container_Name */
    containerName?: string;
    /** 对应 PB：Item_Container */
    itemContainer?: ListItemContainerProperty;
    /** 对应 PB：Is_event_capture（0/1） */
    isEventCapture?: number;
    constructor(data?: Partial<ListContainerProperty>);
    /**
     * 将宿主下发的 JSON 转成 `ListContainerProperty`
     * - 自动兼容 key：camelCase / protoName
     */
    static fromJson(json: any): ListContainerProperty;
    static toJson(model?: ListContainerProperty | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}
/**
 * TextContainerProperty
 *
 * 对齐 PB：`TextContainerProperty`
 */
declare class TextContainerProperty {
    xPosition?: number;
    yPosition?: number;
    width?: number;
    height?: number;
    borderWidth?: number;
    borderColor?: number;
    borderRdaius?: number;
    paddingLength?: number;
    containerID?: number;
    containerName?: string;
    isEventCapture?: number;
    /** 对应 PB：Content */
    content?: string;
    constructor(data?: Partial<TextContainerProperty>);
    /**
     * 将宿主下发的 JSON 转成 `TextContainerProperty`
     * - 自动兼容 key：camelCase / protoName
     */
    static fromJson(json: any): TextContainerProperty;
    static toJson(model?: TextContainerProperty | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}
/**
 * ImageContainerProperty
 *
 * 对齐 PB：`ImageContainerProperty`
 */
declare class ImageContainerProperty {
    xPosition?: number;
    yPosition?: number;
    width?: number;
    height?: number;
    containerID?: number;
    containerName?: string;
    constructor(data?: Partial<ImageContainerProperty>);
    /**
     * 将宿主下发的 JSON 转成 `ImageContainerProperty`
     * - 自动兼容 key：camelCase / protoName
     */
    static fromJson(json: any): ImageContainerProperty;
    static toJson(model?: ImageContainerProperty | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}
/**
 * ImageRawDataUpdateFields （暂时用不到，保留）
 *
 * 对齐 PB：`ImageRawDataUpdate`
 *
 * 注意 `mapRawData`：
 * - 推荐你在 JS 侧传 **number[]**（宿主 `List<int>` 最好接）
 * - 也允许传 base64 string（由宿主自行处理）
 */
declare class ImageRawDataUpdateFields {
    containerID?: number;
    containerName?: string;
    mapSessionId?: number;
    mapTotalSize?: number;
    compressMode?: number;
    mapFragmentIndex?: number;
    mapFragmentPacketSize?: number;
    /** bytes：建议传 number[]（List<int>）或 base64 string */
    mapRawData?: number[] | string | Uint8Array | ArrayBuffer;
    constructor(data?: Partial<ImageRawDataUpdateFields>);
    /** 从 JSON 中读取 ImageRawDataUpdateFields（兼容 key：camelCase / protoName） */
    static fromJson(json: any): ImageRawDataUpdateFields;
    /**
     * 转成宿主可接收的 JSON：
     * - `mapRawData` 如果是 Uint8Array/ArrayBuffer，会被转换为 number[]
     */
    static toJson(model?: ImageRawDataUpdateFields | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}
/**
 * ImageUpdateRawData
 *
 * 对应宿主 Dart：`EvenHubImageContainer`
 *
 * 说明：
 * - 这里只做字段模型 + JSON 映射，不做 protobuf bytes 编解码
 * - `imageData` 建议传 **number[]**（宿主 `List<int>` 最好接）
 * - 若传 Uint8Array/ArrayBuffer，会在 `toJson` 时转换为 number[]
 */
declare class ImageRawDataUpdate {
    containerID?: number;
    containerName?: string;
    imageData?: number[] | string | Uint8Array | ArrayBuffer;
    constructor(data?: Partial<ImageRawDataUpdate>);
    /** 从宿主 JSON 生成 `EvenHubImageContainer`（兼容 key：camelCase / protoName） */
    static fromJson(json: any): ImageRawDataUpdate;
    static toJson(model?: ImageRawDataUpdate | Record<string, any>): Record<string, any>;
    static normalizeImageData(raw: any): number[] | string | undefined;
    toJson(): Record<string, any>;
}

/**
 * EvenHub JSON utils
 *
 * 说明：
 * - 这里只做“JSON 字段取值/简单类型转换”，**不做 protobuf 编解码**
 * - 主要用于兼容宿主侧可能下发的不同 key 命名：camelCase / protoName（如 Container_ID）
 */
type JsonRecord = Record<string, any>;
/**
 * 判断是否是 plain object（非数组）。
 *
 * - `null` / `undefined` -> false
 * - `[]` -> false
 * - `{}` -> true
 */
declare function isObjectRecord(v: any): v is JsonRecord;
/**
 * 从对象中按优先级读取第一个存在的 key。
 *
 * @example
 * pick(json, 'containerID', 'ContainerID', 'Container_ID')
 */
declare function pick<T = any>(obj: any, ...keys: string[]): T | undefined;
/**
 * 将 key 归一化（用于宽松匹配）：
 * - 去掉 `_`
 * - 转小写
 *
 * 例如：
 * - `Container_ID` -> `containerid`
 * - `CurrentSelect_ItemIndex` -> `currentselectitemindex`
 */
declare function normalizeLooseKey(key: string): string;
/**
 * 宽松读取字段：优先精确匹配 keys，其次做 “去下划线+忽略大小写” 匹配。
 *
 * 用于兼容：
 * - `containerID`
 * - `ContainerID`
 * - `Container_ID`
 */
declare function pickLoose<T = any>(obj: any, ...keys: string[]): T | undefined;
/**
 * 将任意值尽量转换为 number（无法转换则返回 undefined）。
 *
 * 说明：
 * - 兼容宿主侧可能把数字以 string 形式下发（例如 `"12"`）
 */
declare function toNumber(v: any): number | undefined;
/**
 * 将任意值尽量转换为 string（无法转换则返回 undefined）。
 *
 * 说明：
 * - number/bool 会被 String(...) 转为 `"1"` / `"true"` 等
 */
declare function toString(v: any): string | undefined;
/**
 * 从对象里读取 number：
 * - 支持宽松 key 匹配（camelCase / protoName）
 * - 支持 string->number
 */
declare function readNumber(obj: any, ...keys: string[]): number | undefined;
/**
 * 从对象里读取 string：
 * - 支持宽松 key 匹配（camelCase / protoName）
 * - 会把 number/bool 转成 string
 */
declare function readString(obj: any, ...keys: string[]): string | undefined;
/**
 * 将任意值转换为 Record（非对象/数组则返回 `{}`）。
 *
 * 常用于：
 * - `payload` / `data` 不是 object 时，避免解析函数抛错
 */
declare function toObjectRecord(v: any): JsonRecord;
/**
 * 将 bytes-like 数据转换为 JSON-friendly 的 payload：
 * - **string**：原样返回（通常是 base64）
 * - **Uint8Array / ArrayBuffer**：转为 number[]（便于宿主按 `List<int>` 接收）
 * - **number[]**：归一化到 0-255
 *
 * 注意：这不是 protobuf bytes 的编码/解码，只是为了让 JSON.stringify 可用。
 */
declare function bytesToJson(v: any): number[] | string | undefined;

/**
 * Start-up page container create result (host -> Web)
 *
 * Align with host (Dart) `EhStartUpPageCreateResult`:
 * - 0 = success
 * - 1 = invalid
 * - 2 = oversize
 * - 3 = outOfMemory
 */
declare enum StartUpPageCreateResult {
    /** 成功 = 0 */
    success = 0,
    /** 无效 = 1 */
    invalid = 1,
    /** 超限 = 2 */
    oversize = 2,
    /** 内存不足 = 3 */
    outOfMemory = 3
}
declare namespace StartUpPageCreateResult {
    /**
     * Convert host int to `StartUpPageCreateResult`.
     *
     * Notes:
     * - Out of range -> `invalid` (safe default)
     */
    function fromInt(value: number): StartUpPageCreateResult;
    /**
     * Best-effort normalization for host return value.
     *
     * Host recommended return type is `int`, but we keep it tolerant:
     * - number: 0~3
     * - numeric string: "0"~"3"
     */
    function normalize(raw: any): StartUpPageCreateResult;
}

/**
 * Send image result (host -> Web)
 *
 * Align with host (Dart) `BleEhSendImageResult`:
 * - 0 = success
 * - 1 = imageException
 * - 2 = imageSizeInvalid / imageToGray4Failed
 * - 3 = sendFailed
 */
declare enum ImageRawDataUpdateResult {
    /** 成功 */
    success = "success",
    /** 图片异常 */
    imageException = "imageException",
    /** 图片尺寸不合规 */
    imageSizeInvalid = "imageSizeInvalid",
    /** 图片转黑白图失败 */
    imageToGray4Failed = "imageToGray4Failed",
    /** 发送失败 */
    sendFailed = "sendFailed"
}
declare namespace ImageRawDataUpdateResult {
    /** Convert enum to host int code. */
    function valueCode(value: ImageRawDataUpdateResult): number;
    /**
     * Convert host int to `BleEhSendImageResult`.
     *
     * Notes:
     * - 2 -> `imageSizeInvalid` (host may also mean `imageToGray4Failed`)
     */
    function fromInt(value: number): ImageRawDataUpdateResult;
    /**
     * Best-effort normalization for host return value.
     *
     * Host recommended return type is `int`, but we keep it tolerant:
     * - number: 0~3
     * - numeric string: "0"~"3"
     * - enum string: "BleEhSendImageResult.success" / "success"
     */
    function normalize(raw: any): ImageRawDataUpdateResult;
    /** 是否成功 */
    function isSuccess(value: ImageRawDataUpdateResult): boolean;
    /** 是否图片异常 */
    function isImageException(value: ImageRawDataUpdateResult): boolean;
    /** 是否图片尺寸不合规 */
    function isImageSizeInvalid(value: ImageRawDataUpdateResult): boolean;
    /** 是否图片转黑白图失败 */
    function isImageToGray4Failed(value: ImageRawDataUpdateResult): boolean;
    /** 是否发送失败 */
    function isSendFailed(value: ImageRawDataUpdateResult): boolean;
}

/**
 * CreateStartUpPageContainer
 *
 * 对应宿主 PB：CreateStartUpPageContainer
 *
 * 这里只定义模型字段，不做 protobuf 编解码。
 */

declare class CreateStartUpPageContainer {
    /** 对应 PB：ContainerTotalNum */
    containerTotalNum?: number;
    /** 对应 PB：List_Object */
    listObject?: ListContainerProperty[];
    /** 对应 PB：Text_Object */
    textObject?: TextContainerProperty[];
    /** 对应 PB：Image_Object */
    imageObject?: ImageContainerProperty[];
    constructor(data?: Partial<CreateStartUpPageContainer>);
    /**
     * 从宿主 JSON 生成 `CreateStartUpPageContainer`
     * - 自动兼容 key：camelCase / protoName（如 List_Object）
     */
    static fromJson(json: any): CreateStartUpPageContainer;
    /**
     * 转为宿主可消费的 JSON（不会做 protobuf 编码，只是字段透传/规范化）
     */
    static toJson(model?: CreateStartUpPageContainer | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * RebuildPageContainer
 *
 * 对应宿主 PB：RebuildPageContainer
 */

declare class RebuildPageContainer {
    /** 对应 PB：ContainerTotalNum */
    containerTotalNum?: number;
    /** 对应 PB：List_Object */
    listObject?: ListContainerProperty[];
    /** 对应 PB：Text_Object */
    textObject?: TextContainerProperty[];
    /** 对应 PB：Image_Object */
    imageObject?: ImageContainerProperty[];
    constructor(data?: Partial<RebuildPageContainer>);
    /**
     * 从宿主 JSON 生成 `RebuildPageContainer`
     * - 自动兼容 key：camelCase / protoName（如 List_Object）
     */
    static fromJson(json: any): RebuildPageContainer;
    /**
     * 转为宿主可消费的 JSON（不会做 protobuf 编码，只是字段透传/规范化）
     */
    static toJson(model?: RebuildPageContainer | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * PB aligned enum: OsEventTypeList (basic)
 *
 * Keep it minimal: only enum values + best-effort normalization.
 */
declare enum OsEventTypeList {
    CLICK_EVENT = 0,
    SCROLL_TOP_EVENT = 1,
    SCROLL_BOTTOM_EVENT = 2,
    DOUBLE_CLICK_EVENT = 3,
    FOREGROUND_ENTER_EVENT = 4,
    FOREGROUND_EXIT_EVENT = 5,
    ABNORMAL_EXIT_EVENT = 6
}
declare namespace OsEventTypeList {
    /**
     * 将宿主下发的 eventType 归一化为 `OsEventTypeList`。
     *
     * 兼容：
     * - number：0~6（PB enum ordinal）
     * - string：`CLICK_EVENT` / `SCROLL_TOP_EVENT` 等
     * - string 简写：`CLICK` / `SCROLL_TOP` 等
     */
    function fromJson(raw: any): OsEventTypeList | undefined;
}

/**
 * PB model: List_ItemEvent（基础字段）
 *
 * 典型场景：
 * - OS 列表组件发生点击/滚动等事件，上报当前选中项信息
 */
declare class List_ItemEvent {
    /** 对应 PB: Container_ID */
    containerID?: number;
    /** 对应 PB: Container_Name */
    containerName?: string;
    /** 对应 PB: CurrentSelect_ItemName */
    currentSelectItemName?: string;
    /** 对应 PB: CurrentSelect_ItemIndex */
    currentSelectItemIndex?: number;
    /** 对应 PB: Event_Type（OsEventTypeList） */
    eventType?: OsEventTypeList;
    constructor(data?: Partial<List_ItemEvent>);
    /**
     * 从 JSON 解析 `List_ItemEvent`。
     *
     * 兼容 key 命名：
     * - camelCase：`containerID`
     * - protoName：`Container_ID`
     *
     * 兼容 value 形态：
     * - 数字可能是 string（通过 `readNumber` 处理）
     */
    static fromJson(input: any): List_ItemEvent;
    static toJson(model?: List_ItemEvent | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * PB model: Text_ItemEvent（基础字段）
 *
 * 典型场景：
 * - OS 文本组件发生点击/进入前台/离开前台等事件
 */
declare class Text_ItemEvent {
    /** 对应 PB: Container_ID */
    containerID?: number;
    /** 对应 PB: Container_Name */
    containerName?: string;
    /** 对应 PB: Event_Type（OsEventTypeList） */
    eventType?: OsEventTypeList;
    constructor(data?: Partial<Text_ItemEvent>);
    /**
     * 从 JSON 解析 `Text_ItemEvent`（兼容 camelCase / protoName key）。
     */
    static fromJson(input: any): Text_ItemEvent;
    static toJson(model?: Text_ItemEvent | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * PB model: Sys_ItemEvent（基础字段）
 *
 * 典型场景：
 * - OS 系统级事件（比如进入前台、退出前台等）
 */
declare class Sys_ItemEvent {
    /** 对应 PB: Event_Type（OsEventTypeList） */
    eventType?: OsEventTypeList;
    constructor(data?: Partial<Sys_ItemEvent>);
    /**
     * 从 JSON 解析 `Sys_ItemEvent`（兼容 camelCase / protoName key）。
     */
    static fromJson(input: any): Sys_ItemEvent;
    static toJson(model?: Sys_ItemEvent | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * EvenHub Event models (Flutter -> Web)
 *
 * This is aligned with:
 * - even_connect: BleEvenHubEvent / BleEvenHubEventType
 * - even_hub: EvenAppInterface.evenHubEvent (type string + map payload)
 *
 * We keep parsing flexible because different host apps may send:
 * - { type: 'listEvent', jsonData: {...} }
 * - { type: 'list_event', data: {...} }
 * - [ 'list_event', {...} ]
 */

declare enum EvenHubEventType {
    listEvent = "listEvent",
    textEvent = "textEvent",
    sysEvent = "sysEvent",
    notSet = "notSet"
}
/**
 * EvenHub 事件 payload（强类型）：
 *
 * - listEvent  -> List_ItemEvent
 * - textEvent  -> Text_ItemEvent
 * - sysEvent   -> Sys_ItemEvent
 * - imgEvent   -> ImageReflashEvent
 *
 * 注意：为了兼容宿主侧“直接透传 json map”的场景，兜底会是 `Record<string, any>`。
 */
type EvenHubEventPayload = List_ItemEvent | Text_ItemEvent | Sys_ItemEvent | Record<string, any>;
/**
 * EvenHub 事件（Flutter -> Web 推送后的统一结构）。
 *
 * 开发者只需要判断哪个属性不为空，就可以直接使用对应的事件对象：
 * ```typescript
 * if (event.listEvent) {
 *   // 处理 listEvent
 * } else if (event.textEvent) {
 *   // 处理 textEvent
 * } else if (event.sysEvent) {
 *   // 处理 sysEvent
 * }
 * ```
 *
 * - `listEvent`: 列表事件（如果存在）
 * - `textEvent`: 文本事件（如果存在）
 * - `sysEvent`: 系统事件（如果存在）
 * - `jsonData`: 原始 JSON（可选，便于调试/回放）
 */
type EvenHubEvent = {
    listEvent?: List_ItemEvent;
    textEvent?: Text_ItemEvent;
    sysEvent?: Sys_ItemEvent;
    jsonData?: Record<string, any>;
};
/** 默认空事件（用于 bridge 初始化时的缓存值）。 */
declare function createDefaultEvenHubEvent(): EvenHubEvent;
/**
 * 从宿主下发的 evenHubEvent JSON 中解析出 `EvenHubEvent`。
 *
 * 兼容多种输入形态：
 * - `{ type: 'listEvent', jsonData: {...} }`
 * - `{ type: 'list_event', data: {...} }`
 * - `[ 'list_event', {...} ]`
 *
 * 解析策略：
 * - 先归一化 `type`
 * - 把数据字段归一到 `jsonData: Record<string, any>`
 * - 再按 type 解析得到对应的事件对象（listEvent/textEvent/sysEvent）
 */
declare function evenHubEventFromJson(input: any): EvenHubEvent;

/**
 * TextContainerUpgrade
 *
 * 对应宿主 PB：TextContainerUpgrade
 */
declare class TextContainerUpgrade {
    /** 对应 PB：Container_ID */
    containerID?: number;
    /** 对应 PB：Container_Name */
    containerName?: string;
    /** 对应 PB：ContentOffset */
    contentOffset?: number;
    /** 对应 PB：ContentLength */
    contentLength?: number;
    /** 对应 PB：Content */
    content?: string;
    constructor(data?: Partial<TextContainerUpgrade>);
    /**
     * 从宿主 JSON 生成 `TextContainerUpgrade`
     * - 自动兼容 key：camelCase / protoName（如 Container_ID）
     */
    static fromJson(json: any): TextContainerUpgrade;
    /** 转为宿主可消费的 JSON（字段透传） */
    static toJson(model?: TextContainerUpgrade | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * ShutDownContaniner
 *
 * 对应宿主 PB：ShutDownContaniner
 * Dart 侧只用到了 exitMode：
 * - 0: Exit immediately
 * - 1: pop up the foreground layer program and wait for the user's operation to decide whether to exit.
 */
declare class ShutDownContaniner {
    exitMode: number;
    [key: string]: any;
    constructor(data?: Partial<ShutDownContaniner>);
    static fromJson(json: any): ShutDownContaniner;
    static toJson(model?: ShutDownContaniner | Record<string, any>): Record<string, any>;
    toJson(): Record<string, any>;
}

/**
 * EvenHub Bridge
 *
 * 用于在 WebView 中桥接 Even App 和 TypeScript SDK 之间的通信
 *
 * 主要功能：
 * 1. Web 页面可以通过桥接调用 Even App 的原生功能（如设置用户信息、设备信息、网络请求等）
 * 2. Web 页面可以监听 Even App 主动推送的通知（如设备状态变化）
 */

/**
 * Even App Bridge 类
 *
 * 提供 Even App 与 WebView 之间的双向通信能力
 *
 * 使用单例模式，确保整个应用中只有一个桥接实例
 *
 * 主要职责：
 * - 管理 Even App 和 WebView 之间的消息传递
 * - 提供就绪状态检查，确保桥接已初始化完成
 */
declare class EvenAppBridge {
    /** 单例实例 */
    private static instance;
    /**
     * 桥接是否已就绪
     * true: 桥接已初始化完成，可以正常使用
     * false: 桥接还在初始化中
     */
    _ready: boolean;
    /**
     * 私有构造函数
     * 使用单例模式，只能通过 getInstance() 方法获取实例
     */
    private constructor();
    /**
     * 获取单例实例
     *
     * @returns EvenAppBridge 的单例实例
     *
     * 如果实例不存在，则创建一个新实例
     * 如果实例已存在，则返回现有实例
     */
    static getInstance(): EvenAppBridge;
    /**
     * 初始化桥接
     *
     * 在浏览器环境中执行以下操作：
     * 1. 将桥接实例暴露到 window.EvenAppBridge，供 Web 页面使用
     * 2. 监听 DOM 加载状态，在 DOM 加载完成后标记为就绪
     * 3. 暴露消息处理函数到 window._evenAppHandleMessage，供 Even App 调用
     */
    private init;
    /**
     * 触发就绪事件
     *
     * 当桥接初始化完成时，触发 BridgeEvent.BridgeReady 事件
     * Web 页面可以监听这个事件，知道桥接已经可以使用了
     */
    private dispatchReadyEvent;
    /**
     * 检查桥接是否就绪
     *
     * @returns true 表示桥接已就绪，可以使用；false 表示还在初始化中
     */
    get ready(): boolean;
    /**
     * 发送消息到 Even APP
     *
     * @param message 要发送的消息对象
     * @returns Promise，resolve 为 Even App 方法执行结果
     *
     * 通过 flutter_inappwebview 的 callHandler 将消息发送到 Even APP 端。
     * Even APP 端需要注册名为 'evenAppMessage' 的 JavaScriptHandler，并在 handler 中 return 结果（或 throw 错误），
     * 这样 Web 侧即可直接 await 调用结果，不需要额外的 response 消息回传。
     */
    private postMessage;
    /**
     * 处理来自 Even App 的消息（公开方法，供外部调用）
     *
     * @param message 来自 Even App 的消息，可以是 JSON 字符串或已解析的对象
     *
     * 这是桥接的核心方法，负责处理所有从 Even App 端发送过来的消息
     *
     * 支持的消息类型：
     * - listen_even_app_data: Even App 主动推送通知（例如 deviceStatusChanged）
     */
    handleEvenAppMessage(message: string | EvenAppMessage): void;
    /**
     * 处理眼镜/设备状态变化
     *
     * @param data 包含设备状态的数据对象
     *
     * 当 Even App 端的设备状态发生变化时，会主动推送这个消息
     * 桥接会更新内部状态，并触发 'deviceStatusChanged' 事件，供 Web 页面监听
     *
     * 状态信息包括：
     * - connectType: 连接状态（none/connecting/connected/disconnected/connectionFailed）
     * - isWearing: 是否佩戴中
     * - batteryLevel: 电池电量
     * - isCharging: 是否正在充电
     * - isInCase: 是否在充电盒中
     */
    private handleGlassesStatusChanged;
    /**
     * 处理 EvenHub 事件变化（Flutter -> Web 推送）
     *
     * @param data 事件数据（兼容多种形态：{type,jsonData} / {type,data} / [type, jsonData]）
     */
    private handleEvenHubEventChanged;
    /**
     * 调用 Even App 方法（从 Web 页面调用）- 通用方法
     *
     * @param method 要调用的 Even App 方法名称
     * @param params 方法参数（可选）
     * @returns Promise，成功时返回 Even App 方法的执行结果，失败时抛出错误
     *
     * 这是 Web 页面调用 Even App 原生功能的主要入口
     */
    callEvenApp(method: EvenAppMethod | string, params?: any): Promise<any>;
    /**
     * 获取用户信息
     *
     * @returns Promise<UserInfo> 返回用户信息
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     * const userInfo = await bridge.getUserInfo();
     * console.log('User:', userInfo.userName);
     * ```
     */
    getUserInfo(): Promise<UserInfo>;
    /**
     * 获取设备信息（眼镜/戒指信息）
     *
     * @returns Promise<DeviceInfo> 返回设备信息
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     * const deviceInfo = await bridge.getDeviceInfo();
     * console.log('Device Model:', deviceInfo?.model);
     * ```
     */
    getDeviceInfo(): Promise<DeviceInfo | null>;
    /**
     * 设置本地存储
     *
     * @param key 存储键名
     * @param value 存储值
     * @returns Promise<void>
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     * await bridge.setLocalStorage('theme', 'dark');
     * ```
     */
    setLocalStorage(key: string, value: string): Promise<boolean>;
    /**
     * 获取本地存储
     *
     * @param key 存储键名
     * @returns Promise<string> 返回存储的值
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     * const theme = await bridge.getLocalStorage('theme');
     * ```
     */
    getLocalStorage(key: string): Promise<string>;
    /**
     * 发送创建启动页容器指令（启动自定义APP时必须调用，后续用 rebuildPageContainer 重建页面）
     *
     * 宿主侧返回 `int`（对齐 EhStartUpPageCreateResult）：
     * - 0 = success
     * - 1 = invalid
     * - 2 = oversize
     * - 3 = outOfMemory
     */
    createStartUpPageContainer(container: CreateStartUpPageContainer): Promise<StartUpPageCreateResult>;
    /** 发送重建页面容器指令 */
    rebuildPageContainer(container: RebuildPageContainer): Promise<boolean>;
    /** 发送更新图片原始数据指令 */
    updateImageRawData(data: ImageRawDataUpdate): Promise<ImageRawDataUpdateResult>;
    /** 发送文本容器升级指令 */
    textContainerUpgrade(container: TextContainerUpgrade): Promise<boolean>;
    /**
     * 发送关闭页面容器指令
     *
     * - exitMode: 0 立即退出；1 弹出前台交互层，由用户操作决定是否退出
     */
    shutDownPageContainer(exitMode?: number): Promise<boolean>;
    /**
     * 监听设备状态变化
     *
     * @param callback 状态变化时的回调函数，参数为完整的设备状态
     * @returns 取消监听的函数
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     *
     * const unsubscribe = bridge.onDeviceStatusChanged((status) => {
     *   console.log('Device status:', status);
     *   if (status.connectType === DeviceConnectType.Connected) {
     *     console.log('Device connected!');
     *   }
     * });
     *
     * // 取消监听
     * unsubscribe();
     * ```
     */
    onDeviceStatusChanged(callback: (status: DeviceStatus) => void): () => void;
    /**
     * 监听 EvenHub 事件推送
     *
     * 使用示例：
     * ```typescript
     * const bridge = EvenAppBridge.getInstance();
     *
     * const unsubscribe = bridge.onEvenHubEvent((event) => {
     *   if (event.listEvent) {
     *     console.log('List event:', event.listEvent);
     *   } else if (event.textEvent) {
     *     console.log('Text event:', event.textEvent);
     *   } else if (event.sysEvent) {
     *     console.log('Sys event:', event.sysEvent);
     *   }
     * });
     *
     * // 取消监听
     * unsubscribe();
     * ```
     */
    onEvenHubEvent(callback: (event: EvenHubEvent) => void): () => void;
}
/**
 * 等待桥接就绪的辅助函数
 *
 * 在 web 页面中使用，确保桥接已初始化完成后再使用
 *
 * @returns Promise<EvenAppBridge> 返回已就绪的桥接实例
 *
 * 使用示例：
 * ```typescript
 * // 等待桥接就绪
 * const bridge = await waitForEvenAppBridge();
 *
 * // 现在可以安全地使用桥接
 * const userInfo = await bridge.getUserInfo();
 * console.log('User Info:', userInfo);
 * ```
 *
 * 工作原理：
 * 1. 首先检查桥接是否已存在且已就绪，如果是则直接返回
 * 2. 如果未就绪，监听 'evenAppBridgeReady' 事件
 * 3. 如果桥接已存在但未标记为就绪，等待 100ms 后再次检查（容错处理）
 */
declare function waitForEvenAppBridge(): Promise<EvenAppBridge>;

export { BridgeEvent, CreateStartUpPageContainer, DeviceConnectType, DeviceInfo, DeviceModel, DeviceStatus, EvenAppBridge, EvenAppMessageType, EvenAppMethod, type EvenHubErrorCode, EvenHubErrorCodeName, type EvenHubEvent, type EvenHubEventPayload, EvenHubEventType, ImageContainerProperty, ImageRawDataUpdate, ImageRawDataUpdateFields, ImageRawDataUpdateResult, type JsonRecord, ListContainerProperty, ListItemContainerProperty, List_ItemEvent, OsEventTypeList, RebuildPageContainer, ShutDownContaniner, StartUpPageCreateResult, Sys_ItemEvent, TextContainerProperty, TextContainerUpgrade, Text_ItemEvent, UserInfo, bytesToJson, createDefaultEvenHubEvent, evenHubEventFromJson, isObjectRecord, normalizeLooseKey, pick, pickLoose, readNumber, readString, toNumber, toObjectRecord, toString, waitForEvenAppBridge };
